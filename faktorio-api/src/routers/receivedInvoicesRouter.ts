import { z } from 'zod'

import { receivedInvoicesTb, contactTb } from '../schema'
import { protectedProc } from '../isAuthorizedMiddleware'
import { trpcContext } from '../trpcContext'
import { eq, desc, and } from 'drizzle-orm'
import { createInsertSchema } from 'drizzle-zod'
import { TRPCError } from '@trpc/server'
import fs from 'fs'
import path from 'path'
import { GoogleGenAI } from '@google/genai'

// Define Zod schema based on Drizzle schema, making fields optional/required as needed for creation
// We will refine this based on the frontend form later
const receivedInvoiceCreateSchema = createInsertSchema(receivedInvoicesTb, {
  id: z.undefined(), // ID is generated by DB
  user_id: z.undefined(), // Will be injected from context
  created_at: z.undefined(), // Defaulted by DB
  updated_at: z.undefined(), // Set on update
  status: z
    .enum(['received', 'verified', 'disputed', 'paid'])
    .default('received'),
  tags: z.array(z.string()).optional().nullable().default([]),
  items: z
    .array(
      z.object({
        description: z.string().optional().nullable(),
        quantity: z.number().optional().nullable(),
        unit_price: z.number().optional().nullable(),
        unit: z.string().optional().nullable(),
        vat_rate: z.number().optional().nullable(),
        total_without_vat: z.number().optional().nullable(),
        total_with_vat: z.number().optional().nullable(),
        accounting_code: z.string().optional().nullable()
      })
    )
    .optional()
    .nullable()
    .default([]),

  // Make non-null fields explicitly required if not defaulted
  supplier_name: z.string().min(1),
  invoice_number: z.string().min(1),
  issue_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/), // YYYY-MM-DD
  due_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/), // YYYY-MM-DD
  total_with_vat: z.number(),
  currency: z.string().default('CZK')
})
  .omit({
    // Fields to be excluded or handled differently
    supplier_contact_id: true // Handle contact linking separately if needed
  })
  .extend({
    // Add fields not directly in DB schema but needed for UI/logic
    supplier_contact_id: z.string().optional().nullable(), // Reference to existing contact
    attachment_data: z.string().optional().nullable() // Base64 encoded image data
  })

// Type for the Gemini OCR processing response
const ocrResponseSchema = z.object({
  supplier_name: z.string().optional(),
  supplier_street: z.string().optional().nullable(),
  supplier_street2: z.string().optional().nullable(),
  supplier_city: z.string().optional().nullable(),
  supplier_zip: z.string().optional().nullable(),
  supplier_country: z.string().optional().nullable(),
  supplier_registration_no: z.string().optional().nullable(),
  supplier_vat_no: z.string().optional().nullable(),
  supplier_email: z.string().optional().nullable(),
  supplier_phone: z.string().optional().nullable(),
  invoice_number: z.string().optional(),
  internal_number: z.string().optional().nullable(),
  variable_symbol: z.string().optional().nullable(),
  expense_category: z.string().optional().nullable(),
  issue_date: z.string().optional(),
  taxable_supply_date: z.string().optional().nullable(),
  due_date: z.string().optional(),
  receipt_date: z.string().optional().nullable(),
  payment_date: z.string().optional().nullable(),
  total_without_vat: z.number().optional().nullable(),
  total_with_vat: z.number().optional(),
  currency: z.string().optional(),
  exchange_rate: z.number().optional().nullable(),
  vat_base_21: z.number().optional().nullable(),
  vat_21: z.number().optional().nullable(),
  vat_base_15: z.number().optional().nullable(),
  vat_15: z.number().optional().nullable(),
  vat_base_10: z.number().optional().nullable(),
  vat_10: z.number().optional().nullable(),
  vat_base_0: z.number().optional().nullable(),
  reverse_charge: z.boolean().optional().nullable(),
  vat_regime: z.string().optional().nullable(),
  payment_method: z.string().optional().nullable(),
  bank_account: z.string().optional().nullable(),
  iban: z.string().optional().nullable(),
  swift_bic: z.string().optional().nullable(),
  items: z
    .array(
      z.object({
        description: z.string().optional().nullable(),
        quantity: z.number().optional().nullable(),
        unit_price: z.number().optional().nullable(),
        unit: z.string().optional().nullable(),
        vat_rate: z.number().optional().nullable(),
        total_without_vat: z.number().optional().nullable(),
        total_with_vat: z.number().optional().nullable(),
        accounting_code: z.string().optional().nullable()
      })
    )
    .optional()
    .nullable(),
  status: z.enum(['received', 'verified', 'disputed', 'paid']).optional()
})

// Helper to load the receivedInvoicesSchema.json
const loadReceivedInvoicesSchema = () => {
  try {
    const schemaPath = path.join(
      __dirname,
      '../json-schema/receivedInvoicesSchema.json'
    )
    const schemaContent = fs.readFileSync(schemaPath, 'utf-8')
    return JSON.parse(schemaContent)
  } catch (error) {
    console.error('Error loading receivedInvoicesSchema.json:', error)
    return null
  }
}

export const receivedInvoicesRouter = trpcContext.router({
  list: protectedProc.query(async ({ ctx }) => {
    const invoices = await ctx.db
      .select()
      .from(receivedInvoicesTb)
      .where(eq(receivedInvoicesTb.user_id, ctx.user.id))
      .orderBy(desc(receivedInvoicesTb.issue_date))
    return invoices
  }),

  getById: protectedProc
    .input(z.object({ id: z.string() }))
    .query(async ({ ctx, input }) => {
      const invoice = await ctx.db
        .select()
        .from(receivedInvoicesTb)
        .where(
          and(
            eq(receivedInvoicesTb.id, input.id),
            eq(receivedInvoicesTb.user_id, ctx.user.id)
          )
        )
        .limit(1)

      if (!invoice.length) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Invoice not found'
        })
      }

      return invoice[0]
    }),

  create: protectedProc
    .input(receivedInvoiceCreateSchema)
    .mutation(async ({ ctx, input }) => {
      const { attachment_data, ...invoiceData } = input

      // Basic check for duplicate invoice for the same supplier/number
      const existing = await ctx.db
        .select({ id: receivedInvoicesTb.id })
        .from(receivedInvoicesTb)
        .where(
          and(
            eq(receivedInvoicesTb.user_id, ctx.user.id),
            eq(receivedInvoicesTb.supplier_name, invoiceData.supplier_name),
            eq(receivedInvoicesTb.invoice_number, invoiceData.invoice_number)
          )
        )
        .limit(1)

      if (existing.length > 0) {
        throw new TRPCError({
          code: 'CONFLICT',
          message:
            'An invoice with this number from this supplier already exists.'
        })
      }

      // Save the invoice
      const [newInvoice] = await ctx.db
        .insert(receivedInvoicesTb)
        // @ts-expect-error - TODO fix this
        .values({
          ...invoiceData,
          user_id: ctx.user.id,
          items: invoiceData.items ?? [],
          tags: invoiceData.tags ?? []
        })
        .returning()

      return newInvoice
    }),

  update: protectedProc
    .input(
      receivedInvoiceCreateSchema.extend({
        id: z.string()
      })
    )
    .mutation(async ({ ctx, input }) => {
      const { id, attachment_data, ...updateData } = input

      // Check if invoice exists and belongs to user
      const existing = await ctx.db
        .select({ id: receivedInvoicesTb.id })
        .from(receivedInvoicesTb)
        .where(
          and(
            eq(receivedInvoicesTb.id, id),
            eq(receivedInvoicesTb.user_id, ctx.user.id)
          )
        )
        .limit(1)

      if (!existing.length) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Invoice not found or you do not have permission to edit it.'
        })
      }

      // Update the invoice
      const [updatedInvoice] = await ctx.db
        .update(receivedInvoicesTb)
        // @ts-expect-error - TODO fix this
        .set({
          ...updateData,
          updated_at: new Date().toISOString()
        })
        .where(eq(receivedInvoicesTb.id, id))
        .returning()

      return updatedInvoice
    }),

  delete: protectedProc
    .input(z.object({ id: z.string() }))
    .mutation(async ({ ctx, input }) => {
      // Check if invoice exists and belongs to user
      const existing = await ctx.db
        .select({ id: receivedInvoicesTb.id })
        .from(receivedInvoicesTb)
        .where(
          and(
            eq(receivedInvoicesTb.id, input.id),
            eq(receivedInvoicesTb.user_id, ctx.user.id)
          )
        )
        .limit(1)

      if (!existing.length) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message:
            'Invoice not found or you do not have permission to delete it.'
        })
      }

      // Delete the invoice
      await ctx.db
        .delete(receivedInvoicesTb)
        .where(eq(receivedInvoicesTb.id, input.id))

      return { success: true }
    }),

  // OCR Image processing with Gemini API
  orcImage: protectedProc
    .input(
      z.object({
        imageData: z.string() // Base64 encoded image data
      })
    )
    .mutation(async ({ ctx, input }) => {
      try {
        // Get the schema for the Gemini model
        const schema = loadReceivedInvoicesSchema()
        if (!schema) {
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Failed to load schema for OCR processing'
          })
        }

        // Check if GEMINI_API_KEY is set
        const apiKey = process.env.GEMINI_API_KEY
        if (!apiKey) {
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Gemini API key is not configured'
          })
        }

        // Initialize the Gemini client
        const genAI = new GoogleGenAI({ apiKey })

        // Clean the image data (remove data:image/jpeg;base64, prefix if present)
        const base64Data = input.imageData.replace(
          /^data:image\/\w+;base64,/,
          ''
        )

        // Prepare the prompt for Gemini
        const prompt = `
        Extract invoice data from this image. The response should be valid JSON according to the following schema:
        ${JSON.stringify(schema)}
        
        Return ONLY the JSON object, nothing else. If you cannot extract some fields, leave them as null.
        For dates, use the format YYYY-MM-DD. If you can't determine the exact date, make your best guess.
        `

        // Get the model

        // Create parts for the content
        // TODO use https://googleapis.github.io/js-genai/main/classes/files.Files.html
        const imagePart = {
          inlineData: {
            mimeType: 'image/jpeg',
            data: base64Data
          }
        }

        // Generate content with the vision model
        const result = await genAI.models.generateContent({
          model: 'gemini-2.0-flash',
          contents: [
            {
              parts: [{ text: prompt }, imagePart]
            }
          ],
          config: {
            temperature: 0.2,
            topP: 0.8,
            topK: 40
          }
        })

        const textContent = result.text ?? ''

        // Try to find JSON object in the response
        let extractedData
        try {
          const jsonMatch = textContent.match(/\{[\s\S]*\}/)
          if (jsonMatch) {
            extractedData = JSON.parse(jsonMatch[0])
          } else {
            throw new Error('No valid JSON found in response')
          }
        } catch (error) {
          console.error('Error parsing Gemini response:', error)
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Failed to parse OCR results'
          })
        }

        // Validate data against our schema
        try {
          const validatedData = ocrResponseSchema.parse(extractedData)
          return validatedData
        } catch (error) {
          console.error('Validation error:', error)
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'OCR results did not match expected format'
          })
        }
      } catch (error) {
        console.error('OCR processing error:', error)
        if (error instanceof TRPCError) {
          throw error
        }
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to process image: ' + (error as Error).message
        })
      }
    })
})

export type ReceivedInvoicesRouter = typeof receivedInvoicesRouter
