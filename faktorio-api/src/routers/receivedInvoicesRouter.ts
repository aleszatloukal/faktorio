import { z } from 'zod'

import { receivedInvoicesTb, contactTb } from '../schema'
import { protectedProc } from '../isAuthorizedMiddleware'
import { trpcContext } from '../trpcContext'
import { eq, desc, and, gte, lt, SQL } from 'drizzle-orm'
import { createInsertSchema } from 'drizzle-zod'
import { TRPCError } from '@trpc/server'
import schema from '../json-schema/receivedInvoicesSchema.json'
import { GoogleGenAI, Schema } from '@google/genai'
import { stringDateSchema } from '../../../faktorio-fe/src/pages/invoice/getInvoiceCreateSchema'

// Define Zod schema based on Drizzle schema, making fields optional/required as needed for creation
// We will refine this based on the frontend form later
const receivedInvoiceCreateSchema = createInsertSchema(receivedInvoicesTb, {
  id: z.undefined(), // ID is generated by DB
  user_id: z.undefined(), // Will be injected from context
  created_at: z.undefined(), // Defaulted by DB
  updated_at: z.undefined(), // Set on update
  status: z
    .enum(['received', 'verified', 'disputed', 'paid'])
    .default('received'),
  tags: z.array(z.string()).optional().nullable().default([]),
  items: z
    .array(
      z.object({
        description: z.string().optional().nullable(),
        quantity: z.number().optional().nullable(),
        unit_price: z.number().optional().nullable(),
        unit: z.string().optional().nullable(),
        vat_rate: z.number().optional().nullable(),
        total_without_vat: z.number().optional().nullable(),
        total_with_vat: z.number().optional().nullable(),
        accounting_code: z.string().optional().nullable()
      })
    )
    .optional()
    .nullable()
    .default([]),

  // Make non-null fields explicitly required if not defaulted
  supplier_name: z.string().min(1),
  invoice_number: z.string().min(1),
  issue_date: stringDateSchema,
  due_date: stringDateSchema,
  total_with_vat: z.number(),
  currency: z.string().max(3).min(3).default('CZK')
})
  .omit({
    // Fields to be excluded or handled differently
    supplier_contact_id: true // Handle contact linking separately if needed
  })
  .extend({
    // Add fields not directly in DB schema but needed for UI/logic
    supplier_contact_id: z.string().optional().nullable(), // Reference to existing contact
    attachment_data: z.string().optional().nullable() // Base64 encoded image data
  })

// Type for the Gemini OCR processing response
const ocrResponseSchema = z.object({
  supplier_name: z.string().optional(),
  supplier_street: z.string().optional().nullable(),
  supplier_street2: z.string().optional().nullable(),
  supplier_city: z.string().optional().nullable(),
  supplier_zip: z.string().optional().nullable(),
  supplier_country: z.string().optional().nullable(),
  supplier_registration_no: z.string().optional().nullable(),
  supplier_vat_no: z.string().optional().nullable(),
  supplier_email: z.string().optional().nullable(),
  supplier_phone: z.string().optional().nullable(),
  invoice_number: z.string().optional(),
  internal_number: z.string().optional().nullable(),
  variable_symbol: z.string().optional().nullable(),
  expense_category: z.string().optional().nullable(),
  issue_date: stringDateSchema,
  taxable_supply_date: stringDateSchema.optional().nullable(),
  due_date: stringDateSchema,
  receipt_date: stringDateSchema.optional().nullable(),
  payment_date: stringDateSchema.optional().nullable(),
  total_without_vat: z.number().optional().nullable(),
  total_with_vat: z.number().optional(),
  currency: z.string().optional(),
  exchange_rate: z.number().optional().nullable(),
  vat_base_21: z.number().optional().nullable(),
  vat_21: z.number().optional().nullable(),
  vat_base_15: z.number().optional().nullable(),
  vat_15: z.number().optional().nullable(),
  vat_base_10: z.number().optional().nullable(),
  vat_10: z.number().optional().nullable(),
  vat_base_0: z.number().optional().nullable(),
  reverse_charge: z.boolean().optional().nullable(),
  vat_regime: z.string().optional().nullable(),
  payment_method: z.string().optional().nullable(),
  bank_account: z.string().optional().nullable(),
  iban: z.string().optional().nullable(),
  swift_bic: z.string().optional().nullable(),
  items: z
    .array(
      z.object({
        description: z.string().optional().nullable(),
        quantity: z.number().optional().nullable(),
        unit_price: z.number().optional().nullable(),
        unit: z.string().optional().nullable(),
        vat_rate: z.number().optional().nullable(),
        total_without_vat: z.number().optional().nullable(),
        total_with_vat: z.number().optional().nullable(),
        accounting_code: z.string().optional().nullable()
      })
    )
    .optional()
    .nullable(),
  status: z.enum(['received', 'verified', 'disputed', 'paid']).optional()
})

export const receivedInvoicesRouter = trpcContext.router({
  list: protectedProc
    .input(
      z.object({
        year: z.number().nullish() // Allow null for 'All'
      })
    )
    .query(async ({ ctx, input }) => {
      const conditions: SQL[] = [eq(receivedInvoicesTb.user_id, ctx.user.id)]

      if (input.year) {
        const year = input.year
        const startDate = `${year}-01-01`
        const endDate = `${year + 1}-01-01`
        conditions.push(gte(receivedInvoicesTb.taxable_supply_date, startDate))
        conditions.push(lt(receivedInvoicesTb.taxable_supply_date, endDate))
      }

      const invoices = await ctx.db
        .select()
        .from(receivedInvoicesTb)
        .where(and(...conditions))
        .orderBy(desc(receivedInvoicesTb.taxable_supply_date))
      return invoices
    }),

  getById: protectedProc
    .input(z.object({ id: z.string() }))
    .query(async ({ ctx, input }) => {
      const invoice = await ctx.db
        .select()
        .from(receivedInvoicesTb)
        .where(
          and(
            eq(receivedInvoicesTb.id, input.id),
            eq(receivedInvoicesTb.user_id, ctx.user.id)
          )
        )
        .limit(1)

      if (!invoice.length) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Invoice not found'
        })
      }

      return invoice[0]
    }),

  create: protectedProc
    .input(receivedInvoiceCreateSchema)
    .mutation(async ({ ctx, input }) => {
      const { attachment_data, ...invoiceData } = input

      // Basic check for duplicate invoice for the same supplier/number
      const existing = await ctx.db
        .select({ id: receivedInvoicesTb.id })
        .from(receivedInvoicesTb)
        .where(
          and(
            eq(receivedInvoicesTb.user_id, ctx.user.id),
            eq(receivedInvoicesTb.supplier_name, invoiceData.supplier_name),
            eq(receivedInvoicesTb.invoice_number, invoiceData.invoice_number)
          )
        )
        .limit(1)

      if (existing.length > 0) {
        throw new TRPCError({
          code: 'CONFLICT',
          message:
            'An invoice with this number from this supplier already exists.'
        })
      }

      // Save the invoice
      const [newInvoice] = await ctx.db
        .insert(receivedInvoicesTb)
        // @ts-expect-error - TODO fix this
        .values({
          ...invoiceData,
          user_id: ctx.user.id,
          items: invoiceData.items ?? [],
          tags: invoiceData.tags ?? []
        })
        .returning()

      return newInvoice
    }),

  update: protectedProc
    .input(
      receivedInvoiceCreateSchema.extend({
        id: z.string()
      })
    )
    .mutation(async ({ ctx, input }) => {
      const { id, attachment_data, ...updateData } = input

      // Check if invoice exists and belongs to user
      const existing = await ctx.db
        .select({ id: receivedInvoicesTb.id })
        .from(receivedInvoicesTb)
        .where(
          and(
            eq(receivedInvoicesTb.id, id),
            eq(receivedInvoicesTb.user_id, ctx.user.id)
          )
        )
        .limit(1)

      if (!existing.length) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Invoice not found or you do not have permission to edit it.'
        })
      }

      // Update the invoice
      const [updatedInvoice] = await ctx.db
        .update(receivedInvoicesTb)
        // @ts-expect-error - TODO fix this
        .set({
          ...updateData,
          updated_at: new Date().toISOString()
        })
        .where(eq(receivedInvoicesTb.id, id))
        .returning()

      return updatedInvoice
    }),

  delete: protectedProc
    .input(z.object({ id: z.string() }))
    .mutation(async ({ ctx, input }) => {
      // Check if invoice exists and belongs to user
      const existing = await ctx.db
        .select({ id: receivedInvoicesTb.id })
        .from(receivedInvoicesTb)
        .where(
          and(
            eq(receivedInvoicesTb.id, input.id),
            eq(receivedInvoicesTb.user_id, ctx.user.id)
          )
        )
        .limit(1)

      if (!existing.length) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message:
            'Invoice not found or you do not have permission to delete it.'
        })
      }

      // Delete the invoice
      await ctx.db
        .delete(receivedInvoicesTb)
        .where(eq(receivedInvoicesTb.id, input.id))

      return { success: true }
    }),

  // OCR Image processing with Gemini API
  orcImage: protectedProc
    .input(
      z.object({
        imageData: z.string() // Base64 encoded image data
      })
    )
    .mutation(async ({ ctx, input }) => {
      try {
        if (!schema) {
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Failed to load schema for OCR processing'
          })
        }

        // Clean the image data (remove data:image/jpeg;base64, prefix if present)
        const base64Data = input.imageData.replace(
          /^data:image\/\w+;base64,/,
          ''
        )

        // Prepare the prompt for Gemini
        const prompt = `
        Extract invoice data from this image. The response should be valid JSON according to the following schema:
        ${JSON.stringify(schema)}
        
        Return ONLY the JSON object, nothing else. If you cannot extract some fields, leave them as null.
        For dates, use the format YYYY-MM-DD. If you can't determine the exact date, make your best guess.
        `

        // Get the model

        // Create parts for the content
        // TODO use https://googleapis.github.io/js-genai/main/classes/files.Files.html
        const imagePart = {
          inlineData: {
            mimeType: 'image/jpeg',
            data: base64Data
          }
        }

        // Generate content with the vision model
        const result = await ctx.googleGenAI.models.generateContent({
          model: 'gemini-2.5-flash-preview-04-17',
          contents: [
            {
              parts: [{ text: prompt }, imagePart]
            }
          ],
          config: {
            systemInstruction: `
            You are a data extraction assistant. Your main objective is to extract invoice data from images of czech invoices.
            `,
            // @ts-expect-error types are not correct
            responseSchema: schema as Schema,
            temperature: 0.2,
            thinkingConfig: {
              includeThoughts: false,
              thinkingBudget: 0
            }
          }
        })

        const textContent = result.text ?? ''

        // Try to find JSON object in the response
        let extractedData
        try {
          const jsonMatch = textContent.match(/\{[\s\S]*\}/)
          if (jsonMatch) {
            extractedData = JSON.parse(jsonMatch[0])
          } else {
            throw new Error('No valid JSON found in response')
          }
        } catch (error) {
          console.error('Error parsing Gemini response:', error)
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Failed to parse OCR results'
          })
        }

        console.log('extractedData for invoice:', extractedData)
        // Validate data against our schema
        try {
          const validatedData = ocrResponseSchema.parse(extractedData)
          return validatedData
        } catch (error) {
          console.error('Validation error:', error)
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'OCR results did not match expected format'
          })
        }
      } catch (error) {
        console.error('OCR processing error:', error)
        if (error instanceof TRPCError) {
          throw error
        }
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to process image: ' + (error as Error).message
        })
      }
    })
})

export type ReceivedInvoicesRouter = typeof receivedInvoicesRouter
